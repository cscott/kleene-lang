\documentclass[letterpaper,12pt]{article}
% \documentclass[a4paper,12pt]{article}
% twocolumn letterpaper 10pt 11pt twoside

% for other type sizes, 8, 9, 10, 11, 12, 14pt, 17pt, 20pt
% \documentclass[14pt]{extarticle}
% also extbook, extletter available
% \usepackage{extsizes}

%\usepackage{endnotes}
% then put \theendnotes where you want them

\usepackage{times}
\usepackage{xspace}
%\usepackage{alltt}
\usepackage{fancyvrb}  % \begin{Verbatim}[fontsize=\small]
% or [fontsize=\footnotesize]

%\usepackage{latexsym}  % \LaTeX{} for LaTeX;  \LaTeXe{} for LaTeX2e
%\usepackage{mflogo}    % \MF{}  for METAFONT;  \MP for METAPOST
\usepackage{url}       % \url{http://www.xrce.xerox.com/people/beesley}

%\usepackage{tipa}
%\include{ipamacros}  % my macros to allow same input for DA and IPA
%\usepackage{desalph}
%\usepackage{arabtex} % see usepackage{buck} and setcode{buck} below
%\usepackage{buck}
%\usepackage{mxedruli}

%\usepackage{epsfig}
%\usepackage{pslatex}  % make whole doc. use postscript fonts

\usepackage{upquote}
% affects \verb and verbatim
% to get straight quotes, straight single quote, straight double
% quotes in verbatim environments

% parallel columns, see also multicol
%\usepackage{parcolumns}
%...
%\begin{parcolumns}[<options>]{3}
%\colchunk{ column 1 text }
%\colchunk{ column 2 text }
%\colchunk{ column 3 text }
%\colplacechunks
%...
%\end{parcolumns}


% for more of these names, see Guide to LaTeX, p. 351
%\providecommand*{\abstractname}{}     % in case the style defines one
%\renewcommand*{\abstractname}{Transcriber notes}
%\renewcommand*{\figurename}{Figure}
%\renewcommand*{\tablename}{Table}
%\renewcommand*{\bibname}{Bibliography}
%\renewcommand*{\refname}{References}

\providecommand{\acro}{}\renewcommand{\acro}{\textsc}
\providecommand{\defin}{}\renewcommand{\defin}{\textsc}

\newcommand{\xmlelmt}{\texttt}
\newcommand{\xmlattr}{\texttt}
\newcommand{\key}{\textbf}
\newcommand{\translit}{\texttt}

% forced pagebreak
%\newpage

%\usepackage{ulem}
%    \uline{important}   underlined text
%    \uuline{urgent}     double-underlined text
%    \uwave{boat}        wavy underline
%    \sout{wrong}        line drawn through word (cross out, strike out)
%    \xout{removed}      marked over with //////.
%    {\em phasized\/}  | In LaTeX, by default, these are underlined; use
%    \emph{asized}     | \normalem or [normalem] to restore italics
%    \useunder{\uwave}{\bfseries}{\textbf}
%                        use wavy underline in place of bold face


%                        \usepackage{natbib}
%\usepackage[authoryear]{natbib}
% compatible with \bibliographystyle{plain}, harvard, apalike, chicago, astron, authordate

%\citet for "textual"   \citet{jon90} ->  Jones et al. (1990)
%\citet[before][after]{key} e.g. \citet[see][p.~47]{jon90} --> 
%         see Jones et al.(1990, chap. 2)
%\citet[chap. 2]{jon90}	    -->    	Jones et al. (1990, chap. 2)
%\citet[after]{key}

%   citep for "parenthetical"
%\citep{jon90}	    -->    	(Jones et al., 1990)
%\citep[chap. 2]{jon90}	    -->    	(Jones et al., 1990, chap. 2)
%\citep[see][]{jon90}	    -->    	(see Jones et al., 1990)
%\citep[see][chap. 2]{jon90}	    -->    	(see Jones et al., 1990, chap. 2)

%\citep for "parenthetical" (author's name in parens)
%\citep  similar
%
%\citet*{key}  list all authors, not just et.al
%\citetext{priv.\ comm.} comes out as (priv. comm.)
%
%just the author or year
%\citeauthor{key} comes out as "Jones et al."
%\citeauthor*{key} comes out as "Jones, Sacco and Vanzetti"
%\citeyear{key}   comes out as 1990
%\citeyearpar{key}            (1990)
%
%Rare stuff:
%use \Citet and \Citep for exceptional forcing of initcap on names
%like 'della Robbia' when it appears first in a sentence.
%
%\citealt like \citet but without parens
%\citealp like \citep but without parens
%


% fancyheadings from The Book (old, obsolete, I think)
%\usepackage{fancyheadings}
%\pagestyle{fancyplain}
% remember the chapter title
%\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
%\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
%\lhead[\fancyplain{}{\small\scshape\thepage}]{\fancyplain{}{\small\scshape\rightmark}}
%\rhead[\fancyplain{}{\small\scshape\leftmark}]{\fancyplain{}{\small\scshape\thepage}}
%\cfoot{}

% new fancyhdr package
%\usepackage{fancyhdr}
%\pagestyle{fancy}
%\fancyhead{}

%% L/C/R denote left/center/right header (or footer) elements
%% E/O denote even/odd pages

%% \leftmark, \rightmark are chapter/section headings generated by the 
%% book document class

%\fancyhead[LE,RO]{\slshape\thepage}
%\fancyhead[RE]{\slshape \leftmark}
%\fancyhead[LO]{\slshape \rightmark}
%\fancyfoot[LO,LE]{\slshape Short Course on Asymptotics}
%\fancyfoot[C]{}
%\fancyfoot[RO,RE]{\slshape 7/15/2002}

% another example
%\fancyhead[LE]{\thepage}
%\fancyhead[CE]{\bfseries Beesley}
%\fancyfoot[CE]{First Draft}
%\fancyhead[CO]{\bfseries My Article Title}
%\fancyhead[RO]{\thepage}
%\fancyfoot[CO]{For Review and Editing Only}
%\renewcommand{\footrulewidth}{0.4pt}

% \vspace{.5cm}
% c, l, r, p{1cm}
%\begin{tabular}{}
%\hline
%   &  &  &   \\
%\hline
%\end{tabular}
% \vspace{.5cm}


% bigbox -- puts a box around a float
% for {figure}, {table} or {center}

\newdimen\boxfigwidth  % width of figure box

\def\bigbox{\begingroup
  % Figure out how wide to set the box in
  \boxfigwidth=\hsize
  \advance\boxfigwidth by -2\fboxrule
  \advance\boxfigwidth by -2\fboxsep
  \setbox4=\vbox\bgroup\hsize\boxfigwidth
  % Make an invisible hrule so that
  % the box is exactly this wide
  \hrule height0pt width\boxfigwidth\smallskip%
% Some environments like TABBING and other LIST environments
% use this measure of line size -
% \LINEWIDTH=\HSIZE-\LEFTMARGIN-\RIGHTMARGIN?
  \linewidth=\boxfigwidth
}
\def\endbigbox{\smallskip\egroup\fbox{\box4}\endgroup}


% example
% \begin{figure}
%   \begin{bigbox}
%     \begin{whatever}...\end{whatever}
%     \caption{}
%     \label{}
%   \end{bigbox}
% \end{figure}
% 
% N.B. put the caption and label inside the bigbox

%\usepackage{graphicx}
% Sample Graphics inclusion; needs graphicx package
%\begin{figure}[ht]
%\begin{bigbox}
%\centering
%\includegraphics{foobar.pdf}   # e.g. PNG, PDF or JPG, _not_ EPS
%\caption{}
%\label{lab:XXX}
%\end{bigbox}
%\end{figure}

%\pagestyle{empty}  % to suppress page numbering

% turn text upside down
%\reflectbox{\textipa{\textlhookp}}
% prevent line break:   \mbox{...}

\hyphenation{hy-po-cri-tical ri-bald}

%%%%%%%%%%%%%%%%%%%%  title %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Proposed Functionality for Case Functions\\
in 0.9.0.18+}
\author{Kenneth R.~Beesley}

% to override automatic "today" date
\date{29 June 2010}

%%%%%%%%%%%%%%%%%%%%%% document %%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle

\begin{abstract}
This document attempts to lay out a coherent and useful semantics for the case
functions.  It turns out to be rather more difficult than I thought.  Comments and corrections would be welcome.
\end{abstract}

\section{Introduction}

\subsection{The Old Implementation in 0.9.0.17}

I've come to believe that my approach to case modification in Kleene 0.9.0.17 was
fundamentally mistaken, especially in the treatment of the ``both''
parameter when the input is an acceptor.  
I've also been testing the case functions in Lauri Karttunen's \texttt{xfst}
version 2.13.3. They seem to
provide a more coherent treatment of case modifications\footnote{Though I did find a couple
of bugs, and an apparent inconsistency between his OptCap() and
OptUpCase() functions.  More on this below.}
that does not suffer from my old ``both'' problems.  In short, it appears
that the \texttt{(x)fst} functions traverse a network, considering each arc label
\texttt{u:l} as a whole (i.e.\@ being able to look at both \texttt{u} and \texttt{l}), and
either changing the arc label or adding new parallel arcs as required by each function.
My old functions looked at the upper and lower sides separately.

I therefore propose to put the previous implementation
aside and rethink the approach to case functions from scratch.  The presentation below is my new proposal for case
semantics.

\subsection{Needs}

The overall plan for the semantics for case functions must consider the following:

\begin{enumerate}
\item
The argument may be an acceptor or a transducer.
\item
If the argument is an acceptor, the result should be an acceptor.
\item
The case function may change the sigma of the resulting network.
\item
A changed sigma may also require the ``promotion'' of OTHER.
\item
The solution should work for the entire Unicode character set, for all characters that
have an uppercase/lowercase distinction.
\end{enumerate}

The function-set will include non-destructive functions like \verb!$&uc($fst, ...)! and
destructive functions like \verb/$&uc!($fst, ...)/.  In practice, the low-level case
functions
always operate on a network in place, and the non-destructive functions simply make
a copy of the argument (where necessary to preserve it) and then operate in-place
on the copy; so, for simplicity,
only the non-destructive versions will be shown in the tables below.

\section{Obligatory Case-changing Functions}

\subsection{Full-path Obligatory Case-changing Functions}

The obligatory case-changing functions are fairly straightforward, changing lowercase labels to
corresponding uppercase labels, or \emph{vice versa}.  If the projection is not
specified (getting the default ``both'' value), the behavior changes the
original labels to the new labels as shown here
(n/a means ``not applicable'', i.e.\@ no change):\footnote{This behavior is
seen in the \texttt{(x)fst} \texttt{UpCase(X)} function.}

\vspace{.5cm}
\noindent
\begin{tabular}{|l|c|c|c|c|c|c|c|}
\hline
Input (to be changed)  & a:a & A:A & a:A & A:a & a:b & a:B & A:b \\
\hline
\verb/$&uc($fst)/  & A:A & n/a & A:A & A:A & A:B & A:B & A:B \\
\hline
\verb/$&lc($fst)/  & n/a & a:a & a:a & a:a & n/a & a:b & a:b \\
\hline
\end{tabular}
\vspace{.5cm}

\noindent
Note that if the input is an acceptor, the output will also be an
acceptor.\footnote{In OpenFst, where all labels are two-level labels of
the form \texttt{u:l}, an acceptor is just a special case of a transducer
wherein all the \texttt{u:l} labels are identity mappings (i.e.\@ \texttt{u
== l}).}

If the input (upper) side is specified, then only the input/upper side labels are changed, and
similarly for the output/lower side.\footnote{This behavior is seen in the
\texttt{(x)fst} \texttt{UpCase(X, U)} and \texttt{UpCase(X, L)} functions.}

\vspace{.5cm}
% c, l, r, p{1cm}
\noindent
\begin{tabular}{|l|c|c|c|c|c|c|c|}
\hline
Input (to be changed)         & a:a & A:A & a:A & A:a & a:b & a:B & A:b \\
\hline
\verb/$&uc($fst, input)/  & A:a & n/a & A:A & n/a & A:b & A:B & n/a \\
\hline
\verb/$&lc($fst, input)/  & n/a & a:A & n/a & a:a & n/a & n/a & a:b \\
\hline
\verb/$&uc($fst, output)/  & a:A & n/a & n/a & A:A & a:B & n/a & A:B \\
\hline
\verb/$&lc($fst, output)/  & n/a & A:a & a:a & n/a & n/a & a:b & n/a \\
\hline
\end{tabular}
\vspace{.5cm}

\subsection{Init Obligatory Case-changing Functions}

The init obligatory versions, \verb!$&init_uc()! and \verb!$&init_lc()!, have the same
effect as the full-path obligatory versions except that the only labels changed are
those exiting the start state of the network.

\section{Optional/Allowing Case Functions}

\subsection{Plan A}

The optional or ``allowing'' case functions are where things get more confusing,
and I will distinguish between Plan A (which will be implemented) and Plan B
(which will not).  In Plan A, the algorithms
always handle original labels in the networks the same way, whether the input FST
is an acceptor or a transducer.  In Plan B, the algorithms handle some
labels differently for acceptors vs.\@ transducers.  Plan A is simpler,
and more parallel to the implementation of the obligatory case-changing
functions described above.  Plan B is messier but might reflect valid
expectations for optional case functions when applied to transducers.  

Plan B (as far as I can see today) is seen only 
in the \texttt{xfst} 2.13.3 implementation of OptCap(), the function that
performs optional initial capitalization.  However, as this behavior of
\texttt{OptCap()} appears to be inconsistent with the Plan-A-like behavior of
\texttt{OptUpCase()}, which performs full-path optional uppercasing, it must be
considered a bit suspect.  

I propose to implement Plan A, and not Plan B---at least not for
now---leaving some notes herein about
Plan B for future reference.

\subsubsection{Full-path Optional/Allowing Functions, Plan A}

The optional or ``allowing'' case functions add new arcs to a network.  The
two tables below are the same as the two above, except that in
optional/allowing functions the
original arc is left intact, and the new labeled arc, if any, is added in
parallel to the original arc.  The first table shows the arcs added when no
side/projection is specified (and so the default ``both'' value is
active).\footnote{This behavior is seen in the \texttt{(x)fst}
\texttt{OptUpCase(X)} function.}

\vspace{.5cm}
\noindent
\begin{tabular}{|l|c|c|c|c|c|c|c|}
\hline
Input (preserved)        & a:a & A:A & a:A & A:a & a:b & a:B & A:b \\
\hline
\verb/$&allow_uc($fst)/  & A:A & n/a & A:A & A:A & A:B & A:B & A:B \\
\hline
\verb/$&allow_lc($fst)/  & n/a & a:a & a:a & a:a & n/a & a:b & a:b \\
\hline
\end{tabular}
\vspace{.5cm}

\noindent
Note that if the input is an acceptor, then the output is an acceptor as
well.

If the input (upper) side is specified, then the labels on new parallel arcs differ
only on the upper side, and
similarly when the output (lower) side is specified.\footnote{This
behavior is seen in the \texttt{(x)fst} \texttt{OptUpCase(X, U)} and
\texttt{OptUpCase(X, L)} functions.}

\vspace{.5cm}
\noindent
\begin{tabular}{|l|c|c|c|c|c|c|c|}
\hline
Input (preserved)               & a:a & A:A & a:A & A:a & a:b & a:B & A:b \\
\hline
\verb/$&allow_uc($fst, input)/  & A:a & n/a & A:A & n/a & A:b & A:B & n/a \\
\hline
\verb/$&allow_lc($fst, input)/  & n/a & a:A & n/a & a:a & n/a & n/a & a:b \\
\hline
\verb/$&allow_uc($fst, output)/  & a:A & n/a & n/a & A:A & a:B & n/a & A:B \\
\hline
\verb/$&allow_lc($fst, output)/  & n/a & A:a & a:a & n/a & n/a & a:b & n/a \\
\hline
\end{tabular}
\vspace{.5cm}

\subsection{Init Optional/Allowing Functions, Plan A}

The init optional/allowing versions, \verb!$&allow_init_uc()! and \verb!$&allow_init_lc()!,
have the same effect as the full-path optional/allowing versions except that the only
labels changed are those exiting the start state of the
network.\footnote{The \texttt{(x)fst} function \texttt{OptCap()}, which
performs optional initial capitalization, does not operate in this way and
appears to be inconsistent with the \texttt{OptUpCase()} function.}

\subsection{Plan B}

At this time, I do not intend to implement Plan B in Kleene.  These notes are
included here for future reference.

Plan B behavior treats an arc labeled with an identity label, e.g.\@ 
\texttt{a:a}, differently depending on whether the overall network is an
acceptor or a transducer.

\subsubsection{Full-path Optional/Allowing Functions, Plan B}

Plan B is \emph{not} seen in the \texttt{(x)fst} 2.13.3 implementation of the
\texttt{OptUpCase()} function, which does full-path optional uppercasing;
rather it has Plan A behavior.

\subsubsection{Init Optional/Allowing Functions, Plan B}

A key difference between Plan A and Plan B involves the treatment of
identity-labels, e.g.\@ a:a, in a network that is a transducer.  As far as I
can tell today, the Plan B behavior is seen only in the \texttt{(x)fst}
\texttt{OptCap()} function, which handles optional initial uppercasing, e.g.\@

\begin{Verbatim}[fontsize=\small]
define foo OptCap(a x:y) ;
\end{Verbatim}

\noindent 
In Plan A, the algorithm would simply add a single new arc labeled
\texttt{A}\footnote{This label would be \texttt{A:A} in OpenFst.} parallel to
the original arc labeled \texttt{a}.\footnote{This label would be \texttt{a:a}
in OpenFst.}  In contrast, in Plan B, as currently implemented, the algorithm
sees the original \texttt{a} arc as being in the context of a transducer
(because there is an arc labeled \texttt{x:y} in the same network), treats it
like \texttt{a:a}, and judges that there are \emph{three} ways that \texttt{a:a}
might be capitalized: either on both sides as \texttt{A:A}, or on only one
side, as either \texttt{a:A} or \texttt{A:a}.  Thus in the example

\begin{Verbatim}[fontsize=\small]
define foo OptCap(a b) ;
\end{Verbatim}

\noindent
where the argument is an acceptor, the \verb!OptCap()! algorithm
adds a single arc, labeled \texttt{A} parallel to the original arc labeled
\texttt{a}; whereas in the example

\begin{Verbatim}[fontsize=\small]
define foo OptCap(a x:y) ;
\end{Verbatim}

\noindent
the same algorithm adds three arcs, labeled \texttt{A}, \texttt{a:A}
and \texttt{A:a}, respectively, parallel to the original arc labeled \texttt{a}.

This current implementation of \texttt{OptCap(a x:y)} appears to be
inconsistent with the behavior of \texttt{OptUpCase(a x:y)}

\begin{Verbatim}[fontsize=\small]
define foo OptUpCase(a x:y) ;
\end{Verbatim}

\noindent
which follows Plan A, adding a single new arc labeled \texttt{A} to the
original arc labeled \texttt{a}.

Because of the uniqueness of Plan-B behavior in \texttt{OptCap()}, and its
apparent inconsistency with \texttt{OptUpCase()}, I have decided not to
implement anything like Plan B at this time.

\section{Case Insensitivity}

\subsection{Full-path Case Insensitivity}

The \verb!ci! (case insensitivity) functions also add arcs parallel to existing arcs.
Note that in Kleene \verb!allow_ci! and \verb!ci! are aliases for the same
functionality.  This first chart shows the behavior for the default ``both''
value.

\vspace{.5cm}
\noindent
\begin{tabular}{|l|p{.7cm}|p{.7cm}|p{.7cm}|p{.7cm}|p{.7cm}|p{.7cm}|p{.7cm}|}
\hline
Input   (preserved)      & a:a         & A:A         & a:A         & A:a         & a:b                  & a:B         & A:b \\
\hline
\verb/$&allow_ci($fst)/  & A:A a:A A:a & a:A A:a a:a & A:A A:a a:a & a:A A:A a:a & A:B
A:b a:B & A:B A:b a:b & A:B a:B a:b\\
\hline
\end{tabular}
\vspace{.5cm}

\noindent
Note that for every arc labeled \texttt{u:l}, where \texttt{u} and \texttt{l} are
letters with an uppercase/lowercase distinction, the algorithm adds three new arcs.


If a projection is specified, then only one side of the network is made
case-insensitive by adding new parallel arcs.  (One new arc is added for each
original arc that involves letter labels that have an uppercase/lowercase
distinction.)

\vspace{.5cm}
\noindent
\begin{tabular}{|l|c|c|c|c|c|c|c|}
\hline
Input (preserved)               & a:a & A:A & a:A & A:a & a:b & a:B & A:b \\
\hline
\verb/$&allow_ci($fst, input)/  & A:a & a:A & A:A & a:a & A:b & A:B & a:b \\
\hline
\verb/$&allow_ci($fst, output)/  & a:A & A:a & a:a & A:A & a:B & a:b & A:B \\
\hline
\end{tabular}
\vspace{.5cm}

\subsection{Initial Case-insensitivity}

The initial case-insensitivity functions, \verb!$&allow_init_ci()! and its
alias \verb!$&init_ci()!, behave like the full-path versions except that
they affect only the arcs exiting the start state.

\section{Invert Case}

I propose to remove the invert-case functions (supplied in 0.9.0.17) because I
can't think of any good use for them, and because including them might just
cause confusion.

\section{Sigma}

Changing the case qualities of a network can add and remove symbols from the sigma.
The Kleene intepreter contains a low-level function\footnote{correctSigmaOther()} that attempts to correct the sigma and OTHER of a
network, but it may not be adequate.  Getting the sigma correct will require careful
thinking and testing.

\section{OTHER}

When a network contains OTHER, adding and removing symbols from the sigma could also
have potential effects on the overall meaning of OTHER.  We will have to study this
issue, comparing our results with those of \texttt{fst}.


\end{document}
