
\documentclass[letterpaper,12pt]{article}
% \documentclass[a4paper,10pt]{article}
% twocolumn letterpaper 10pt 11pt twoside

% for other type sizes, 8, 9, 10, 11, 12, 14pt, 17pt, 20pt
% \documentclass[14pt]{extarticle}
% also extbook, extletter available
% \usepackage{extsizes}

%\usepackage{endnotes}
% then put \theendnotes where you want them

\usepackage{times}
\usepackage{xspace}

\usepackage[outerbars]{changebar}
% supports \cbstart and \cbend, also the changebar environment
% need to run pdflatex multiple times


%\usepackage{alltt}
\usepackage{fancyvrb}  % \begin{Verbatim}[fontsize=\small]
% or [fontsize=\footnotesize]
\usepackage{upquote}
% affects \verb and verbatim
% to get straight quotes, straight single quote, straight double
% quotes in verbatim environments


%\usepackage{latexsym}  % \LaTeX{} for LaTeX;  \LaTeXe{} for LaTeX2e
%\usepackage{mflogo}    % \MF{}  for METAFONT;  \MP for METAPOST
%\usepackage{url}       % \url{http://www.xrce.xerox.com/people/beesley}
%\usepackage{lscape}    % allows \begin{landscape} ... \end{landscape}

%\usepackage{tipa}
%\include{ipamacros}  % my macros to allow same input for DA and IPA
%\usepackage{desalph}
%\usepackage{arabtex} % see usepackage{buck} and setcode{buck} below
%\usepackage{buck}
%\usepackage{mxedruli}

%\usepackage{epsfig}
%\usepackage{pslatex}  % make whole doc. use postscript fonts

% parallel columns, see also multicol
%\usepackage{parcolumns}
%...
%\begin{parcolumns}[<options>]{3}
%\colchunk{ column 1 text }
%\colchunk{ column 2 text }
%\colchunk{ column 3 text }
%\colplacechunks
%...
%\end{parcolumns}


% for more of these names, see Guide to LaTeX, p. 351
%\providecommand*{\abstractname}{}     % in case the style defines one
%\renewcommand*{\abstractname}{Transcriber notes}
%\renewcommand*{\figurename}{Figure}
%\renewcommand*{\tablename}{Table}
%\renewcommand*{\bibname}{Bibliography}
%\renewcommand*{\refname}{References}

\providecommand{\acro}{}\renewcommand{\acro}{\textsc}
\providecommand{\defin}{}\renewcommand{\defin}{\textsc}

\newcommand{\xmlelmt}{\texttt}
\newcommand{\xmlattr}{\texttt}
\newcommand{\key}{\textbf}
\newcommand{\translit}{\texttt}

% forced pagebreak
%\newpage

%\usepackage{ulem}
%    \uline{important}   underlined text
%    \uuline{urgent}     double-underlined text
%    \uwave{boat}        wavy underline
%    \sout{wrong}        line drawn through word (cross out, strike out)
%    \xout{removed}      marked over with //////.
%    {\em phasized\/}  | In LaTeX, by default, these are underlined; use
%    \emph{asized}     | \normalem or [normalem] to restore italics
%    \useunder{\uwave}{\bfseries}{\textbf}
%                        use wavy underline in place of bold face


%                        \usepackage{natbib}
%\usepackage[authoryear]{natbib}
% compatible with \bibliographystyle{plain}, harvard, apalike, chicago, astron, authordate

%\citet for "textual"   \citet{jon90} ->  Jones et al. (1990)
%\citet[before][after]{key} e.g. \citet[see][p.~47]{jon90} --> 
%         see Jones et al.(1990, chap. 2)
%\citet[chap. 2]{jon90}	    -->    	Jones et al. (1990, chap. 2)
%\citet[after]{key}

%   citep for "parenthetical"
%\citep{jon90}	    -->    	(Jones et al., 1990)
%\citep[chap. 2]{jon90}	    -->    	(Jones et al., 1990, chap. 2)
%\citep[see][]{jon90}	    -->    	(see Jones et al., 1990)
%\citep[see][chap. 2]{jon90}	    -->    	(see Jones et al., 1990, chap. 2)

%\citep for "parenthetical" (author's name in parens)
%\citep  similar
%
%\citet*{key}  list all authors, not just et.al
%\citetext{priv.\ comm.} comes out as (priv. comm.)
%
%just the author or year
%\citeauthor{key} comes out as "Jones et al."
%\citeauthor*{key} comes out as "Jones, Sacco and Vanzetti"
%\citeyear{key}   comes out as 1990
%\citeyearpar{key}            (1990)
%
%Rare stuff:
%use \Citet and \Citep for exceptional forcing of initcap on names
%like 'della Robbia' when it appears first in a sentence.
%
%\citealt like \citet but without parens
%\citealp like \citep but without parens
%


% fancyheadings from The Book (old, obsolete, I think)
%\usepackage{fancyheadings}
%\pagestyle{fancyplain}
% remember the chapter title
%\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
%\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
%\lhead[\fancyplain{}{\small\scshape\thepage}]{\fancyplain{}{\small\scshape\rightmark}}
%\rhead[\fancyplain{}{\small\scshape\leftmark}]{\fancyplain{}{\small\scshape\thepage}}
%\cfoot{}

% new fancyhdr package
%\usepackage{fancyhdr}
%\pagestyle{fancy}
%\fancyhead{}

%% L/C/R denote left/center/right header (or footer) elements
%% E/O denote even/odd pages

%% \leftmark, \rightmark are chapter/section headings generated by the 
%% book document class

%\fancyhead[LE,RO]{\slshape\thepage}
%\fancyhead[RE]{\slshape \leftmark}
%\fancyhead[LO]{\slshape \rightmark}
%\fancyfoot[LO,LE]{\slshape Short Course on Asymptotics}
%\fancyfoot[C]{}
%\fancyfoot[RO,RE]{\slshape 7/15/2002}

% another example
%\fancyhead[LE]{\thepage}
%\fancyhead[CE]{\bfseries Beesley}
%\fancyfoot[CE]{First Draft}
%\fancyhead[CO]{\bfseries My Article Title}
%\fancyhead[RO]{\thepage}
%\fancyfoot[CO]{For Review and Editing Only}
%\renewcommand{\footrulewidth}{0.4pt}

% \vspace{.5cm}
% c, l, r, p{1cm}
%\begin{tabular}{}
%\hline
%   &  &  &   \\
%\hline
%\end{tabular}
% \vspace{.5cm}


% bigbox -- puts a box around a float
% for {figure}, {table} or {center}

\newdimen\boxfigwidth  % width of figure box

\def\bigbox{\begingroup
  % Figure out how wide to set the box in
  \boxfigwidth=\hsize
  \advance\boxfigwidth by -2\fboxrule
  \advance\boxfigwidth by -2\fboxsep
  \setbox4=\vbox\bgroup\hsize\boxfigwidth
  % Make an invisible hrule so that
  % the box is exactly this wide
  \hrule height0pt width\boxfigwidth\smallskip%
% Some environments like TABBING and other LIST environments
% use this measure of line size -
% \LINEWIDTH=\HSIZE-\LEFTMARGIN-\RIGHTMARGIN?
  \linewidth=\boxfigwidth
}
\def\endbigbox{\smallskip\egroup\fbox{\box4}\endgroup}


% example
% \begin{figure}
%   \begin{bigbox}
%     \begin{whatever}...\end{whatever}
%     \caption{}
%     \label{}
%   \end{bigbox}
% \end{figure}
% 
% N.B. put the caption and label inside the bigbox

%\usepackage{graphicx}
% Sample Graphics inclusion; needs graphicx package
%\begin{figure}[ht]
%\begin{bigbox}
%\centering
%\includegraphics{foobar.pdf}   # e.g. PNG, PDF or JPG, _not_ EPS
%\caption{}
%\label{lab:XXX}
%\end{bigbox}
%\end{figure}

%\pagestyle{empty}  % to suppress page numbering

% turn text upside down
%\reflectbox{\textipa{\textlhookp}}
% prevent line break:   \mbox{...}

\hyphenation{hy-po-cri-tical ri-bald}

%%%%%%%%%%%%%%%%%%%%  title %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Strategy Proposal and \\
Initial Task List \\
for RTN Support in Kleene}
\author{Kenneth R.~Beesley}

% to override automatic "today" date
\date{21 September 2010}

%\usepackage{makeidx}
%\makeindex
% see \printindex below in the document
%\usepackage{showidx}   % print proofs showing indexed locations!!!

%%%%%%%%%%%%%%%%%%%%%% document %%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle

%\tableofcontents
%\listoffigures
%\listoftables

\begin{abstract}
After several talks between myself and Phil Sours, we now agree that Kleene can and
should support two distinct conventions for representing a reference to a subnetwork
in an \acro{rtn} (Recursive Transition Network): the
so-called \acro{sap-rtn} convention, as expected by Phil Sours' \acro{rtn} runtime
code; and the OpenFst-\acro{rtn} convention, as expected by several operations
provided in the OpenFst library.  

Although there are differences between and particular potential advantages to
the two approaches, we believe that in
practice there is little or no overlap between the needs and expectations of the
anticipated users of the two conventions.  It is even conceivable that
additional conventions might
need to be accommodated in the future.
\end{abstract}

\section{Executive Summary---Estimated Tasks}


\vspace{.5cm}
% c, l, r, p{1cm}
\begin{tabular}{|p{9cm}|l|l|}
\hline
\textbf{Task Description} & \textbf{Hours} & Who \\
\hline
Implement SapRtnConventions and OpenFstRtnConventions statements; generate
a warning message when the conventions are changed & 3 &  Ken  \\
\hline
Modify \$\&sub(\$fst) to be sensitive to SapRtnConventions and
OpenFstRtnConventions & 3 &  Ken  \\
\hline
Modify promotion of OTHER to be sensitive to SapRtnConventions  & 6 &  Ken  \\
\hline
Modify tokenization of test strings, in the GUI, to ignore special symbols
referring to subnetworks in an RTN & 6 & Ken \\
\hline
Modify \$\&embedRtnSubnets() to be sensitive to SapRtnConventions  & 3 &  Ken  \\
\hline
Modify \$\&expandRtn() to block expansion for RTNs using
SapRtnConventions  & 3 &  Ken  \\
\hline
Handle currently unpredictable effects of generalizing RTN handling & 12 &
Ken\\
\hline
Review and update Kleene user documentation regarding RTNs & 6 & Ken\\
\hline
Detect illegal mapping of SAP-RTN subnetwork reference to anything other than
epsilon & Backlog TBD & Ken \\
\hline
Investigate need to mark RTN conventions in XML output  & Backlog TBD &  Ken  \\
\hline
Investigate possible expansion of RTNs using SapRtnConventions  & Backlog TBD &  Phil  \\
\hline
\end{tabular}
\vspace{.5cm}


\section{What is an \acro{rtn}?}

A Recursive Transition Network (\acro{rtn}) looks a lot like a finite-state network,
consisting of states and labeled arcs, but
really isn't.  Where a true finite state network contains arcs with labels
representing only terminal symbols such as \emph{a}, \emph{b}, \emph{c} and epsilon,
an \acro{rtn} can also contain arcs with
\emph{non}-terminal labels that are interpreted---by appropriate runtime code---as
references to subnetworks.  \acro{rtn}s can represent languages and relations that
are formally context-free, i.e.\@ not regular and therefore not representable as a simple
\acro{fst} (Finite State Transducer).  If an \acro{rtn} contains only references that
are non-cylic, then it is formally regular but may be significantly more compact than the
equivalent ``expanded'' \acro{fst}.

When the runtime code encounters, inside an \acro{rtn}, a reference to a subnetwork,
it pushes the current location on a stack, ``pushes'' to the indicated
subnetwork, and continues matching the input against that subnetwork.  If the
subnetwork-match succeeds, the runtime code ``pops'' back to the
previous location, and continues matching in the original network.  Thus in an \acro{rtn},
references to subnetworks are treated much like function calls, and the stack is much
like a subroutine call-stack.

The big issues, to be discussed above, are

\begin{enumerate}
\item
What exactly do ``references to subnetworks'' look like in an \acro{rtn}? and

\item
What external operations, in the runtime code or other algorithms, are triggered by
the references to subnetworks?

\end{enumerate}

\section{Conventions for Denoting a Push to a Subnetwork}

\subsection{\acro{sap-rtn} Conventions}

\subsubsection{Simple Subnetwork References}

Under the \acro{sap-rtn} conventions, a simple reference to a subnetwork named \verb!$foo! will be an arc labeled just
\verb!'$foo':'$foo'!.  In the Kleene source file, such a reference could be
indicated syntactically as just

\begin{Verbatim}[fontsize=\small]
'$foo'
\end{Verbatim}

\noindent
i.e.\@ as a multichar symbol that looks like the name of the network, or, more explicitly, as

\begin{Verbatim}[fontsize=\small]
'$foo':'$foo'
\end{Verbatim}

\noindent
or, using a built-in pseudo-function \verb!$&sub()!,

\begin{Verbatim}[fontsize=\small]
$&sub($foo)
\end{Verbatim}

This last \verb!$&sub($foo)! syntax is potentially more flexible, allowing the same
Kleene source code to be interpreted in different ways for different kinds or versions of
runtime code.  However, in the anticipated context of \acro{sap} pattern matching, the need to interpret the same source code in different ways
is more theoretical than practical.  Linguists writing rules for the \acro{sap-rtn}
runtime code are unlikely to know about, let alone need, alternatives.

In reality, the labels on network arcs are integers, but Kleene maintains a mapping
between symbol names and integers, so an arc labeled \verb!'$foo':'$foo'! is really
labeled \verb!i:i!, where \verb!i! is the integer associated with the symbol
\verb!'$foo'!.  As the symbol-integer mapping is maintained automatically, Kleene
users never have to worry about the integers and can think in terms of the symbol
names.

\subsubsection{Subnetwork References with Mapping to Epsilon}

In addition to handling simple subnet references, the \acro{sap-rtn} runtime code can
perform an addition trick: pushing to a subnetwork, matching the input, and
\emph{mapping the output to epsilon (the empty string)}.  At the arc level, this kind
of reference is indicated by the label \verb!'$foo':$eps!, i.e.\@ with the multichar
symbol \verb!'$foo'! on the upper/input side and epsilon on the lower/output side.

Syntactically in Kleene source code, such a reference could be encoded as

\begin{Verbatim}[fontsize=\small]
'$foo':$eps
\end{Verbatim}

\noindent
or, with the trivial definition of a useful \verb!$&suppress()! function,

\begin{Verbatim}[fontsize=\small]
$&suppress($x) {
	return $x:$eps ;
}
\end{Verbatim}

\noindent
it could be denoted as

\begin{Verbatim}[fontsize=\small]
$&suppress('$foo')
\end{Verbatim}

\noindent
or

\begin{Verbatim}[fontsize=\small]
$&suppress($&ref($foo))
\end{Verbatim}

\noindent
Again, the labels on arcs are really just integers, but Kleene maintains the
symbol-integer mapping automatically, and pattern writers never have to worry about
the actual integer values.

Because any multichar symbol spelled with an initial dollar sign, e.g.\@
\verb!'$name'!, is interpreted by the
\acro{sap-rtn} runtime code as a
reference to a subnet, here \$name, pattern writers using the
\acro{sap-rtn} convention must
not try to use
multichar symbols that start with the dollar sign \verb!$! for any other purpose.
This should not be a problem in our anticipated pattern-matching applications.


\subsection{OpenFst Conventions}

It is anticipated that the use of OpenFst conventions for encoding references to subnets
in an \acro{rtn} will not be used by pattern writers at \acro{sap}.  However, they may
well be useful for other applications, and they will be the conventions expected by anyone using Kleene as a
general wrapper for the underlying OpenFst library.

OpenFst provides some native, off-the-shelf support for \acro{rtn}s in the form of
the
Replace() and ReplaceFst() functions, plus some new and mostly untested functions in release
1.2.3 that convert
\acro{rtn}s into \acro{pdt}s (Pushdown Transducers).  For these functions to work, the symbol reference to a subnetwork
must appear on the \emph{lower/output} side of the arcs (the opposite of
the \acro{sap-rtn} convention), and the symbol on the
upper/input side can be anything, but is typically epsilon.

As already implemented by Ken Beesley, the OpenFst reference symbols are spelled with two
initial underscores, e.g.\@ \verb!'__$foo'! on the output/lower side of an arc would be a symbol reference to the subnetwork
named \verb!$foo!.\footnote{In reality, the arc labels are integers, but Kleene automatically
maintains the symbol-integer mapping, letting users think in terms of label names.}

Symbol names with two initial underscores are already reserved by fiat for Kleene internal system
use as special characters.  When using the OpenFst conventions for references to
subnetworks, programmers will use the built-in pseudo-function \verb!$&sub()!, e.g.\@
the syntax

\begin{Verbatim}[fontsize=\small]
$&sub($foo)
\end{Verbatim}

\noindent
will result in an arc labeled \verb!$eps:'__$foo'!.  The use of the two underscores
allows users to define and use other normal multichar symbols starting with the dollar sign, which
may be useful in non-pattern-matching applications like tokenization.

\subsection{Semantic Differences}

In the \acro{sap-rtn} applications, there exists the possibility of pushing to a
subnetwork, and mapping the output to epsilon \emph{in the runtime code}, which is not possible using the
off-the-shelf \acro{rtn} functions and conventions from OpenFst.

In the \acro{sap-rtn} runtime code, a push to a subnet really is like a function
call, and the memory savings are permanent.  The ``delayed'' OpenFst ReplaceFst()
function allows an OpenFst-format \acro{rtn} to be applied to input, using
composition, but the references to subnetworks are expanded into copies of the
referred-to subnetworks as needed (``lazily'') 
to handle the input, so typically the base network gets bigger, compromising the initial
memory savings.

\section{Implications for Kleene}

Kleene is a language for building finite-state networks, and, given an appropriate
set of conventions, for building finite-state networks that are to be interpreted as \acro{rtn}s
by appropriate runtime code.  Although most of the heavy lifting of \acro{rtn}
matching is done in the runtime code, there are still several implications for the Kleene
language
itself.

\subsection{Declaring to Kleene which Convention is in Use}

Because the \acro{sap-rtn} and OpenFst conventions use different spellings for
references to subnetworks, \verb!'$foo'! vs.\@ \verb!'__$foo'!, and because the references
appear on opposites sides of the arc label (on the upper side for \acro{sap-rtn}s, and on
the lower side for OpenFst \acro{rtn}s) Kleene has to be told
which convention is in use.  Ken has suggested the use of the special command

\begin{Verbatim}[fontsize=\small]
SapRtnConventions ;
\end{Verbatim}

\noindent
to tell Kleene that the \acro{sap-rtn} conventions are in use.  This command would
naturally be put in the \texttt{PatternDefs.kl} file, which already contains numerous
definitions for pattern matching, and most pattern writers would never need to know
it was there.

For users writing other applications that might want to use the off-the-shelf OpenFst Replace(),
ReplaceFst() and \acro{pdt} functions, the command might be

\begin{Verbatim}[fontsize=\small]
OpenFstRtnConventions ;
\end{Verbatim}

It is highly unlikely that any user would be tempted to switch conventions mid-stream, but
any such change could be answered with a warning message.

The convention-setting statements will result in the setting of certain
system variables\footnote{These variables will probably be parallel to
those that users can turn off and on to control whether automatic
optimization of networks is performed.} that the interpreter can
interrogate during its operation.  Future experimentation may reveal a
need for more individual fine-tuned access to these variables, but we'll
face that if and when it becomes necessary.

\subsection{Conventions and the \$\&sub() Pseudo-Function}

If \texttt{SapRtnConventions} are in use, Kleene will interpret \verb!$&sub($foo)!
as the label \verb!'$foo':'$foo'!.


If \texttt{OpenFstConventions} are in use, Kleene will interpret \verb!$&sub($foo)!
as the label \verb!$eps:'__$foo'!.


\subsection{Special Symbols and \acro{other}}

Although references to subnetworks are, at the arc level, just multichar symbols,
Kleene needs to know that they are special, not like normal terminal characters
\emph{a}, \emph{b} or \emph{c}, or even like terminal multichar symbols such as
\emph{[Noun]} or \emph{[Pl]}.  In particular, such symbols should not
be included when ``promoting'' the value of \acro{other} when two networks are combined via
operations like union and composition; and, if Kleene is performing tokenization of
an input string for testing, it should not try to tokenize subnet-reference names as
input tokens.

If \texttt{SapRtnConventions} are in use, Kleene will continue to treat all
reserved multichar symbols starting with \verb!__!, plus all multichar symbols
starting with \verb!$!, as special symbols not to be used when promoting
\acro{other}.

If \texttt{OpenFstConventions} are in use, Kleene will continue to treat all
reserved multichar symbols starting with \verb!__!, including all multichar symbols
starting with \verb!__$!, as special symbols not to be used when promoting
\acro{other}.


\subsection{Subnet References and \$\&embedRtnSubnets(\$rtn)}

If \texttt{SapRtnConventions} are in use, Kleene will collect the set of all upperside
symbols beginning with \verb!$!, and union a copy of each referred-to network with
the result, prefixing each subnet \verb!$name! with the symbols \verb!__SUBNETWORKS!
and \verb!$name!.


If \texttt{OpenFstConventions} are in use, Kleene will collect the set of all
lowerside
symbols beginning with \verb!__$!, and union a copy of each referred-to network with
the result, prefixing each subnet \verb!$name! with the symbols \verb!__SUBNETWORKS!
and \verb!__$name!.  This is the current behavior, but it may evolve as needs, if
any, are clarified in the future.

\subsection{Subnet References and \$\&expandRtn(\$rtn)}

The Kleene \verb!$&expandRtn($rtn)! function is based on the OpenFst Replace() and
ReplaceFst() functions.  The purpose of Replace() and ReplaceFst() is to turn an
\acro{rtn}, if and only if it is mathematically regular, into an equivalent ``expanded''
\acro{fst}.

If \texttt{OpenFstConventions} are in use, and \verb!$&expandRtn($rtn)! is called, Kleene will first make sure that the
\acro{rtn} is regular,\footnote{The ``delayed'' ReplaceFst() function provides a
boolean method that checks for cyclic dependencies that would make a network infinite
in size if replacement were attempted.  If an \acro{rtn} lacks cyclic dependencies,
then it is regular and can be expanded via Replace().} and if so, will replace all references to
subnetworks with copies of the referred-to subnets, using the OpenFst Replace()
function.  The result is a normal \acro{fst}.  This is the current behavior.

\acro{rtn}s built for the anticipated \acro{sap} pattern matching will be, as best
we can predict,
almost always non-regular and therefore not expandable by a function such as
Replace().  Even if such a network is (exceptionally) regular, lacking cyclic references, any use of
the ``mapping to epsilon'' capability (implemented in the \acro{sap-rtn} runtime
code) will also make the network incompatible with Replace().  And finally, the
convention for representing references to subnetworks in \acro{sap-rtn}s is not
compatible with Replace().  At this time,
therefore, the \verb!$&expandRtn($rtn)! function, based on Replace() and
ReplaceFst(), is not compatible with \acro{rtn}s
built using the \texttt{SapRtnConventions}.

In the future, as needs become apparent, we might experiment with expanding
\acro{sap-rtn}s:

\begin{enumerate}
\item
If an \acro{sap-rtn} really is regular, and does not use the ``mapping to epsilon''
trick, it could be trivially converted into a network that is compatible with
Replace().

\item
If an \acro{sap-rtn} really is regular, but does use ``mapping to epsilon'', then it
should be possible to write a new version of Replace(), called something like
ReplaceSapRtn(), that both performs the replacements and maps selected outputs to
epsilon, producing an expanded \acro{fst} that, when applied, is equivalent to
what happens with the original \acro{rtn} and the \acro{sap-rtn} runtime code.

\end{enumerate}

\noindent
But at this time, expanding \acro{sap-rtn}s, even where mathematically possible, does
not seem to be a practical need.

\subsection{Marking \acro{rtn} Conventions in \acro{xml} Output?}

At some time, it might become necessary to enhance the \acro{xml} output of networks
to indicate which \acro{rtn} conventions were used during its definition.  However,
at this time, we do not yet see a need for such an enhancement.

\subsection{Detecting Illegal Mappings of Subnet References}

Under \texttt{SapRtnConventions}, a reference to a subnetwork that looks like
\verb!'$foo':$eps! causes the \acro{sap-rtn} runtime code to push to \verb!$foo!
\emph{and} to map anything
that \verb!$foo! matches to epsilon (the empty string), effectively suppressing the
output. This special reference, i.e.\@ the arc label \verb!'$foo':$eps!, uses the normal general Kleene colon syntax representing the
cross-product; but semantically, the only mapping that the runtime code can handle is
mapping to epsilon.  If the user mistakenly indicates any other non-identity mapping, e.g.
\verb!'$foo':a!, then ideally this would be detected by the Kleene interpreter and
signaled as an error.  This could be done in the future when general semantic
checking is implemented in a separate class that ``knows'' which operands can be
validly acted on by each operation.


\end{document}
